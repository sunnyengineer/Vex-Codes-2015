
#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    lif,            sensorPotentiometer)
#pragma config(Sensor, in2,    ritlif,         sensorPotentiometer)
#pragma config(Sensor, in3,    leftLF,         sensorLineFollower)
#pragma config(Sensor, in4,    midLF,          sensorLineFollower)
#pragma config(Sensor, in5,    gyro,           sensorGyro)
#pragma config(Sensor, in6,    rightLF,        sensorLineFollower)
#pragma config(Sensor, in7,    accel,          sensorAccelerometer)
#pragma config(Sensor, dgtl1,  ,               sensorDigitalOut)
#pragma config(Sensor, dgtl3,  sky,            sensorDigitalOut)
#pragma config(Sensor, dgtl4,  rig,            sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  lft,            sensorQuadEncoder)
#pragma config(Sensor, dgtl8,  brake,          sensorDigitalOut)
#pragma config(Motor,  port1,           FLD,           tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           RLL,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           BRD,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           RRL,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           LLL,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           RightClaw,     tmotorServoStandard, openLoop)
#pragma config(Motor,  port7,           LRL,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           LeftClaw,      tmotorServoStandard, openLoop)
#pragma config(Motor,  port9,           FRD,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          BLD,           tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////
int x;
int y;
int Userinput(){
	while(true){
		if(nLCDButtons == 1){
			return 1;
			}if(nLCDButtons == 4){
			return 2;
		}
	}
}

void LED(){

	bLCDBacklight = true;
	displayLCDCenteredString(0, "Side?");
	displayLCDString(1, 0, "Red         Blue");
	x = Userinput();
	displayLCDCenteredString(0, "Position?");
	displayLCDString(1, 0, "Left       Right");
	waitInMilliseconds(500);
	y = Userinput();
	if(x == 1 && y == 1){
		displayLCDCenteredString(0, "Re-left, 2 points");}
	if(x == 2 && y == 1){
		displayLCDCenteredString(0, "Blue-left, 2 points");}
	if(x == 1 && y == 2){
		displayLCDCenteredString(0, "Red-Right, 2 points");}
	if(x == 2 && y == 2){
		displayLCDCenteredString(0, "Blue-Right, 2 points");}
}

void pre_auton(){
	if(!bIfiRobotDisabled){ //Allows robot to return to driver mode if cortex experiences a power glitch
		return;
	}
	LED();
	bStopTasksBetweenModes = false;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////
int kp = 1.3;  // kill switches and constants for PID, do not mess with these
int ki = 1;
bool aut = false;
int error;
int integral(int in){
	while(true){
		in = in + error;
		return in;
	}
}

int derivative(int err){
	while(true){
		err = error;
		int der = error - err;
		return der;
	}
}
void lift(string direction, int rheight, int lheight){// decently self explanatory, it either goes up or down according to the
	//right potentiometer height and left potentiometer height, with left being negative
	if(direction == "up"){
		while(SensorValue[ritlif] < rheight){
			motor[RRL] = 127;
			motor[RLL] = 127;}

		while(SensorValue[lif] > lheight){
			motor[LLL] = 127;
			motor[LRL] = 127;}
}
	if(direction == "down"){
		while(SensorValue[ritlif] > rheight){
			motor[RRL] = -127;
			motor[RLL] = -127;}
		while(SensorValue[lif] < lheight){
			motor[LLL] = -127;
			motor[LRL] = -127;}
	}
	motor[RRL] = 0;
	motor[RLL] = 0;
	motor[LLL] = 0;
	motor[LRL] = 0;
}

void stp(){//kills drive motors
	motor[FLD] = 0;
	motor[FRD] = 0;
	motor[BLD] = 0;
	motor[BRD] = 0;}

void reset(string encode){//resets encoders and gyro based upon what is put in parenthesis
	if(encode == "lef"){
		SensorValue[lft] = 0;}
	if(encode == "rit"){
		SensorValue[rig] = 0;}
	if(encode == "lif"){
		SensorValue[lif] = 0;}
	if(encode == "giro"){
		SensorValue[gyro] = 1;}
}
void brace(){
	SensorValue(brake) = 1;}
void go(){
	SensorValue(brake) = 0;}
//error, inte, deri, and speed are all part of PID
void move(int direction, int target){//standard forward movement
	if(direction == 1){
		while(SensorValue[lft] < target){
			int error = target - SensorValue[lft];
			int inte = integral(0);
			if (error == 0){
				inte = 0;}
			if ( abs(error) > 40){
				inte = 0;}
			int deri = derivative(error);
			int speed = (error * kp) + (inte * ki) + deri;
			if(speed > 127){
				speed = 127;}
			if(error < 60){
				motor[FLD] = (speed*2);
				motor[FRD] = (speed*2);
				motor[BLD] = (speed*2);
				motor[BRD] = (speed*2);}
			else{
			motor[FLD] = speed;
			motor[FRD] = speed;
			motor[BLD] = speed;
			motor[BRD] = speed;}
			}
		stp();}
}
void movebac(int target){//standard movement back, target int is distance travelled, positive
	while(SensorValue[lft] > target){
		int error = SensorValue[lft] - target;
		int inte = integral(0);
		if (error == 0){
			inte = 0;}
		if (abs(error) > 40){
			inte = 0;}
		int deri = derivative(error);
		int speed = ( error * kp) + (inte * ki) + deri;
		if(speed > 127){
			speed = 127;}
		if(error < 60){
			motor[FLD] = (-speed*2.5);
			motor[FRD] =(-speed*2.5);
			motor[BLD] =(-speed*2.5);
			motor[BRD] =(-speed*2.5);}
		else{
		motor[FLD] = -speed*2;
		motor[FRD] = -speed*2;
		motor[BLD] = -speed*2;
		motor[BRD] = -speed*2;}}
	stp();
}
//don't worry about the music
void slowmovebac(int target){//standard movement back, target int is distance travelled, positive
	while(SensorValue[lft] > target){
		int error = SensorValue[lft] - target;
		int inte = integral(0);
		if (error == 0){
			inte = 0;}
		if (abs(error) > 40){
			inte = 0;}
		int deri = derivative(error);
		int speed = ( error * kp) + (inte * ki) + deri;
		if(speed > 127){
			speed = 127;}
		if(error < 60){
			motor[FLD] = (-speed*0.43);
			motor[FRD] =(-speed*0.43);
			motor[BLD] =(-speed*0.43);
			motor[BRD] =(-speed*0.43);}
		else{
		motor[FLD] = -speed*0.43;
		motor[FRD] = -speed*0.43;
		motor[BLD] = -speed*0.43;
		motor[BRD] = -speed*0.43;}}
	stp();
}
void turn(string direction, int angle){// turn function, L is left turn with a positive desired turn and R is right and
	//negative
	if(direction == "L"){
		while(SensorValue[gyro] < angle){
			int error = angle - SensorValue[lft];
			int inte = integral(0);
			while (error < 0){
				error = -error;}
			if (error == 0){
				inte = 0;}
			if ( abs(error) > 40){
				inte = 0;}
			int deri = derivative(error);
			int speed = (error * kp) + (inte * ki) + deri;
			if(speed > 127){
				speed = 127;}
			if(error < 60){
				motor[FLD] = -(speed*2);
				motor[FRD] = (speed*2);
				motor[BLD] = -(speed*2);
				motor[BRD] = (speed*2);}
			else{
			motor[FLD] = -(speed);
			motor[FRD] = (speed);
			motor[BLD] = -(speed);
			motor[BRD] = (speed);}
		}
	}
	if(direction == "R"){
		while(SensorValue[gyro] > angle){
			int error = SensorValue[lft] - angle;
			int inte = integral(0);
			while (error < 0){
				error = -error;}
			if (error == 0){
				inte = 0;}
			if ( abs(error) > 40){
				inte = 0;}
			int deri = derivative(error);
			int speed = (error * kp) + (inte * ki) + deri;
			if(speed > 127){
				speed = 127;}
			if(error < 60){
				motor[FLD] = (speed*3);
				motor[FRD] = -(speed*3);
				motor[BLD] = (speed*3);
				motor[BRD] = -(speed*3);}
			else{
			motor[FLD] = (speed*2);
			motor[FRD] = -(speed*2);
			motor[BLD] = (speed*2);
			motor[BRD] = -(speed*2);}}
	}
stp();
}
void swinturn(string direction, int angle, int forw){// turn function, L is left turn with a positive desired turn and R is right and
	//negative
	if(direction == "L" && forw == 0){
		while(SensorValue[gyro] < angle){
			int error = angle - SensorValue[lft];
			int inte = integral(0);
			while (error < 0){
				error = -error;}
			if (error == 0){
				inte = 0;}
			if ( abs(error) > 40){
				inte = 0;}
			int deri = derivative(error);
			int speed = (error * kp) + (inte * ki) + deri;
			if(speed > 127){
				speed = 127;}
			if(error < 50){
				motor[FLD] = -(speed*1.35);
				motor[BLD] = -(speed*1.35);}
			else{
			motor[FLD] = -(1.4*speed);
			motor[BLD] = -(1.4*speed);}
			}
	}
		if(direction == "L" && forw == 1){
		while(SensorValue[gyro] < angle){
			int error = angle - SensorValue[lft];
			int inte = integral(0);
			while (error < 0){
				error = -error;}
			if (error == 0){
				inte = 0;}
			if ( abs(error) > 40){
				inte = 0;}
			int deri = derivative(error);
			int speed = (error * kp) + (inte * ki) + deri;
			if(speed > 127){
				speed = 127;}
			if(error < 60){
				motor[FRD] = (speed*2);
				motor[BRD] = (speed*2);}
			else{
			motor[FRD] = (speed);
			motor[BRD] = (speed);}
			}
	}
	if(direction == "R" && forw == 0){
		while(SensorValue[gyro] > angle){
			int error =  SensorValue[lft] - angle;
			int inte = integral(0);
			while (error < 0){
				error = -error;}
			if (error == 0){
				inte = 0;}
			if ( abs(error) > 40){
				inte = 0;}
			int deri = derivative(error);
			int speed = (error * kp) + (inte * ki) + deri;
			if(speed > 127){
				speed = 127;}
			if(error < 60){
				motor[FRD] = -(speed*2);
				motor[BRD] = -(speed*2);}
			else{
			motor[FRD] = -(speed);
			motor[BRD] = -(speed);}
			}
	}
	if(direction == "R" && forw == 1){
		while(SensorValue[gyro] > angle){
			int error = SensorValue[lft] - angle;
			int inte = integral(0);
			while (error < 0){
				error = -error;}
			if (error == 0){
				inte = 0;}
			if ( abs(error) > 40){
				inte = 0;}
			int deri = derivative(error);
			int speed = (error * kp) + (inte * ki) + deri;
			if(speed > 127){
				speed = 127;}
			if(error < 60){
				motor[FLD] = (speed*2);
				motor[BLD] = (speed*2);}
			else{
			motor[FLD] = (speed);
			motor[BLD] = (speed);}}
	}
stp();
}

void feed(){//opens claws
	setServo(LeftClaw,120);
	setServo(RightClaw,-120);
}
void close(){//puts claws in starting postion
	setServo(RightClaw, -30);
	setServo(LeftClaw, -10);
}
void skygrip(){//puts claws inwards to grab a skyrise
	setServo(LeftClaw, -70);
	setServo(RightClaw,40);}

void fold(){
	setServo(LeftClaw, -120);
	setServo(RightClaw, 120);}

string lef = "lef", rit = "rit", R = "R", L = "L", lfi = "lif", U = "up", Do = "down", giro = "giro";
//defines all of the strings to be used to represent all of the values determined in the functions above
void auto(){
	aut = true;

	if(x == 1 && y == 2){//one of the good autons-red side
   	reset(lef);
	  movebac(-100);
		lift(U, 1250, 2640);
		reset(giro);
		turn(L, 5);
		reset(lef);
		move(1,240);

		brace();
		lift(Do, 340, 3655);
		reset(lef);
		go();
		movebac(-40);
		brace();
		reset(giro);
		skygrip();
		turn(R, -1720);
		go();
		feed();
		waitInMilliseconds(100);
		reset(lef);
		move(1, 195);
		close();
		lift(U,2155, 1575);
		reset(lef);
		move(1, 85);
		reset(giro);
		swinturn(R, -800, 1);
		reset(lef);
		movebac(-50);
		lift(Do, 2000, 1730);
		reset(lef);
		movebac(-150);
		feed();
	}
		if(x == 2 && y == 2){
		reset(lef);
		movebac(-180);
		close();
		reset(giro);
		turn(R, -208);
		lift(U, 500, 3300);
		feed();
		reset(lef);
		move(1, 73);
		waitInMilliseconds(200);
		skygrip();
		lift(U, 910, 2890);
		reset(lef);
		movebac(-485);//high bat 290, low bat 310
		reset(giro);
		turn(R, -305);//at 205, high bat 180, 250, 225
		reset(lef);
		move(1, 40);
		lift(Do, 800, 3000);
		reset(lef);
		move(1, 50);
		reset(lef);
		movebac(-70);//ow bat 110, high bat 60
		feed();
		lift(Do, 340,3450);
		close();
		reset(lef);
		movebac(-40);
		reset(lef);
		reset(giro);
		waitInMilliseconds(10);
		swinturn(L, 690, 0);
		feed();
		reset(lef);
		move(1, 250);
		close();
		reset(lef);
		movebac(-100);
		lift(U, 310, 3695);
		reset(giro);
		turn(R, -630);//lwbat 740, high bat 700
		lift(U, 975, 3030);
		reset(lef);
		move(1, 310);
		lift(Do, 800, 3205);
		feed();
		reset(lef);
		movebac(-100);
	}
	if(x == 1 && y == 1){
		fold();
		reset(lef);
		movebac(-180);
		close();
		reset(giro);
		turn(L, 203);
		lift(U, 575, 3315);
		feed();
		reset(lef);
		move(1, 63);
		waitInMilliseconds(200);
		skygrip();
		lift(U, 925, 2875);
		reset(lef);
		movebac(-340);//low bat
		reset(giro);
		turn(L, 283);//ow bat
		reset(lef);
		movebac(-50);//low bat
		lift(Do, 800, 3000);
		reset(lef);
		move(1, 65);
		reset(lef);
		movebac(-20);//low bat
		feed();
		lift(Do, 360,3635);
		reset(lef);
		waitInMilliseconds(5);
		movebac(-20);
		reset(giro);
		turn(R, -250);

		reset(lef);
		movebac(-70);
		reset(giro);
		swinturn(R, -365, 0);
		feed();
		reset(lef);
		move(1, 375);
		close();
		reset(lef);
		lift(U, 340, 3665);
		movebac(-100);
		reset(giro);
		turn(L, 670);//low bat
		lift(U, 975, 3030);
		reset(lef);
		move(1, 145);
		lift(Do, 800, 3205);
		feed();
		reset(lef);
		movebac(-100);
	}
	if(x == 2 && y == 1){//other good auton-blue side
		reset(lef);
	  movebac(-100);
		lift(U, 1250, 2640);
		move(1,70);
		brace();
		lift(Do, 340, 3655);
		reset(lef);
		go();
		movebac(-50);
		brace();
		reset(giro);
		skygrip();
		turn(L, 1650);
		go();
		feed();
		waitInMilliseconds(100);
		reset(lef);
		move(1, 160);
		close();
		lift(U,2155, 1575);
		reset(lef);
		move(1, 110);
		reset(giro);
		swinturn(L, 800, 1);
		reset(lef);
		movebac(-50);
		lift(Do, 2000, 1730);
		reset(lef);
		movebac(-500);
		feed();


	}
}
task autonomous(){

	auto();
	aut = false;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////
void mturn(string direction, int angle){
	if(direction == "L"){
		while(SensorValue[gyro] < (angle-10) && vexRT(Btn7D) != 1){
			int error = angle - SensorValue[lft];
			int inte = integral(0);
			while (error < 0){
				error = -error;}
			if (error == 0){
				inte = 0;}
			if ( abs(error) > 40){
				inte = 0;}
			int deri = derivative(error);
			int speed = (error * kp) + (inte * ki) + deri;
			if(speed > 127){
				speed = 127;}
			motor[FLD] = -speed;
			motor[FRD] = speed;
			motor[BLD] = -speed;
			motor[BRD] = speed;}
	}
	if(direction == "R"){
		while(SensorValue[gyro] > (angle+10) && vexRT(Btn7D) != 1){
			int error = -angle + SensorValue[lft];
			int inte = integral(0);
			if (error == 0){
				inte = 0;}
			if ( abs(error) > 40){
				inte = 0;}
			int deri = derivative(error);
			int speed = (error * kp) + (inte * ki) + deri;
			if(speed > 127){
				speed = 127;}
			motor[FLD] = -speed;
			motor[FRD] = speed;
			motor[BLD] = -speed;
			motor[BRD] = speed;}
	}
}
void stahp(){
	motor[RRL] = 0;
	motor[RLL] = 0;
	motor[LLL] = 0;
	motor[LRL] = 0;}

void mlift(string direction, int rheight, int lheight){
	if(direction == "up"){
		while(SensorValue[ritlif] < rheight&& vexRT[Btn7D] != 1){
			motor[RRL] = 127;
			motor[RLL] = 127;}

		while(SensorValue[lif] > lheight && vexRT[Btn7D] != 1){
			motor[LLL] = 127;
			motor[LRL] = 127;}
}
	if(direction == "down"){
		while(SensorValue[ritlif] > rheight && vexRT[Btn7D] != 1){
			motor[RRL] = -127;
			motor[RLL] = -127;}
		while(SensorValue[lif] < lheight && vexRT[Btn7D] != 1){
			motor[LLL] = -127;
			motor[LRL] = -127;}
	}
}
string mainBattery;
int battery2Level;
string expanderbattery;
int precis;
void macro(){
		if(vexRT[Btn8L] == 1){
			mlift(U, 1372, 2378);}

		if(vexRT[Btn8U] == 1){
			mlift(U, 2230, 1500);}

		if(vexRT[Btn8R] == 1){
			mlift(U, 710, 3180);}
		if(vexRT[Btn8D] == 1){
			if(SensorValue(ritlif) < 700){
				mlift(U, 530, 3370);}
			if(SensorValue(ritlif) > 700){
				mlift(Do, 800, 3100);
				}
			}
		if(vexRT[Btn7R] == 1){
			reset(giro);
			mturn(L, 270);}
		if(vexRT[Btn7L] == 1){
			reset(giro);
			mturn(R, -270);}
		}

task usercontrol(){
		bLCDBacklight = true;
		while(true){
		if(vexRT(Btn7U) == 1){
			stopTask(autonomous);}
		precis = vexRT[Btn8DXmtr2] ? 2 : 1;
		if(vexRT(Btn7D) == 1){
			SensorValue(brake) = 1;}
		else{
			SensorValue(brake) = 0;}
				motor[FRD] = vexRT(Ch2)/precis;
				motor[FLD] = vexRT(Ch3)/precis;
				motor[BRD] = vexRT(Ch2)/precis;
				motor[BLD] = vexRT(Ch3)/precis;
				waitInMilliseconds(10);
				motor[FRD] = 0;
				motor[FLD] = 0;
				motor[BRD] = 0;
				motor[BLD] = 0;
			macro();
			clearLCDLine(0);
			clearLCDLine(1);
			//Display the Primary Robot battery voltage
			displayLCDString(0, 0, "Primary: ");
			sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
			displayNextLCDString(mainBattery);

			//Display the Backup battery voltage
			displayLCDString(1, 0, "Expander: ");
			battery2Level = (int)((float)SensorValue[in8] /280 );
			sprintf(expanderbattery, "%1.2f%c", battery2Level, 'V');
			displayNextLCDString(expanderbattery);

			if(vexRT(Btn5U) == 1){
				motor[RRL] = 127;
				motor[RLL] = 127;
				motor[LLL] = 127;
				motor[LRL] = 127;
			}
			else if(vexRT(Btn5D) == 1){
				motor[RRL] = -127;
				motor[RLL] = -127;
				motor[LLL] = -127;
				motor[LRL] = -127;
			}
			else{
				stahp();}


			if(vexRT[Btn6U] == 1){
				setServo(LeftClaw,120);
				setServo(RightClaw,-120);}

			else if(vexRT[Btn6D] == 1){
				setServo(LeftClaw, -70);
				setServo(RightClaw,40);}

			else{
				setServo(RightClaw, -30);
				setServo(LeftClaw, -10);}
		}
}
