#pragma config(Sensor, in1,    zAccel,         sensorAccelerometer)
#pragma config(Sensor, in2,    yAccel,         sensorAccelerometer)
#pragma config(Sensor, in3,    xAccel,         sensorAccelerometer)
#pragma config(Sensor, dgtl3,  lef,            sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  rit,            sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  lif,            sensorQuadEncoder)
#pragma config(Motor,  port1,           BackRightDrive, tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           BackLeftDrive, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           LeftBottomLift, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           RightClaw,     tmotorServoStandard, openLoop)
#pragma config(Motor,  port5,           TopRightLift,  tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           TopLeftLift,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           LeftClaw,      tmotorServoStandard, openLoop)
#pragma config(Motor,  port8,           LeftFrontDrive, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           RightFrontDrive, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          RightBottomLift, tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////
int x;
int y;
int z;
int Userinput(){
    while(true){
        if(nLCDButtons == 1){
            return 1;
            }if(nLCDButtons == 4){
            return 2;
        }
    }
}
void LED(){
    displayLCDCenteredString(0, "Side?");
    displayLCDString(0, 0, "Red         Blue");
    x = Userinput();
    displayLCDCenteredString(0, "Position?");
    displayLCDString(0, 0, "Left     Right");
    waitInMilliseconds(500);
    y = Userinput();
    displayLCDCenteredString(0, "Backup?");
    displayLCDString(0, 0, "Yes         No");
    waitInMilliseconds(500);
    z = Userinput();
    if(x == 1 && y == 1 && z == 1){
        displayLCDCenteredString(0, "Red, left");
        }if(x == 2 && y == 1 && z == 1){
        displayLCDCenteredString(0, "Blue, left");
        }if(x == 1 && y == 2 && z == 1){
        displayLCDCenteredString(0, "Red, Right");
        }if(x == 2 && y == 2 && z == 1){
        displayLCDCenteredString(0, "Blue, Right");
    }
}
void pre_auton(){
	if(!bIfiRobotDisabled){ //Allows robot to return to driver mode if cortex experiences a power glitch
        return;
    }
	LED();
	bStopTasksBetweenModes = false;

}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////
int error;
 int integral(int in){
	while(true){
		in = in + error;
		return in;
	}
}

int derivative(int err){
	while(true){
		err = error;
		int der = error - err;
		return der;
	}
}

void reset(string encode){
	if(encode == "lft"){
		SensorValue(lef) = 0;}
}
void reseth(string enc){
	if(enc == "lif"){
		SensorValue(lif) = 0;}
}
void move(int dis){
	while(SensorValue[lef] < dis){
        int error = dis - SensorValue[lef];
				int inte = integral(0);
				if (error == 0)
				{
				inte = 0;
				}
				if ( abs(error) > 40)
				{
				inte = 0;
				}
				int deri = derivative(error);

				int speed = error + inte + deri;
				if(speed > 127){
					int speed = 127;}
				motor[BackLeftDrive] = speed;
        motor[LeftFrontDrive] = speed;
        motor[BackRightDrive] = speed;
        motor[RightFrontDrive] = speed;
      }
    motor[BackLeftDrive] = 0;
    motor[LeftFrontDrive] = 0;
    motor[BackRightDrive] = 0;
    motor[RightFrontDrive] = 0;}

void moveback(int dis){
	while(SensorValue[rit] < dis){
			motor[BackLeftDrive] = -127;
      motor[LeftFrontDrive] = -127;
      motor[BackRightDrive] = -127;
      motor[RightFrontDrive] = -127;}
	 motor[BackLeftDrive] = 0;
   motor[LeftFrontDrive] = 0;
   motor[BackRightDrive] = 0;
   motor[RightFrontDrive] = 0;}

void movegrab(int distance){
    while(SensorValue[rit] > distance){
        motor[BackLeftDrive] = 127;
        motor[LeftFrontDrive] = 127;
        motor[BackRightDrive] = 127;
        motor[RightFrontDrive] = 127;
        setServo(LeftClaw,120);
	      setServo(RightClaw,-120);
    }
    motor[BackLeftDrive] = 0;
    motor[LeftFrontDrive] = 0;
    motor[BackRightDrive] = 0;
    motor[RightFrontDrive] = 0;
    setServo(RightClaw, -10);
	  setServo(LeftClaw, -10);}

void turn(string side, int degre){
	if(side == "lft"){
		while(SensorValue[rit] > degre){
			motor[BackRightDrive] = 127;
			motor[RightFrontDrive] = 127;
			motor[LeftFrontDrive] = -127;
			motor[BackLeftDrive]  = -127;}
		motor[BackRightDrive] = 0;
		motor[RightFrontDrive] = 0;
		motor[LeftFrontDrive] = 0;
		motor[BackLeftDrive]  = 0;
	}
	if(side == "rig"){
		while(SensorValue[rit] < degre){
			motor[BackRightDrive] = -127;
			motor[RightFrontDrive] = -127;
			motor[LeftFrontDrive] = 127;
			motor[BackLeftDrive]  = 127;
			}
		motor[BackRightDrive] = 0;
		motor[RightFrontDrive] = 0;
		motor[LeftFrontDrive] = 0;
		motor[BackLeftDrive]  = 0;}
	}

void grab(){
	setServo(LeftClaw,120);
	setServo(RightClaw,-120);
waitInMilliseconds(500);
	setServo(RightClaw, -10);
	setServo(LeftClaw, -10);}



void lift(string vertic, int place){
	if(vertic == "down"){
		motor[LeftBottomLift] = 127;
		motor[RightBottomLift] = 127;
		motor[TopLeftLift] = 127;
		motor[TopRightLift] = 127;
		untilRotations(place, lif);
		motor[LeftBottomLift] = 0;
		motor[RightBottomLift] = 0;
		motor[TopLeftLift] = 0;
		motor[TopRightLift] = 0;}
	if(vertic == "up"){
		motor[LeftBottomLift] = -127;
		motor[RightBottomLift] = -127;
		motor[TopLeftLift] = -127;
		motor[TopRightLift] = -127;
		untilRotations(place, lif);
		motor[LeftBottomLift] = 0;
		motor[RightBottomLift] = 0;
		motor[TopLeftLift] = 0;
		motor[TopRightLift] = 0;}
}
void movebackgrab(int dist){
		while(SensorValue[rit] < dist){
			motor[BackLeftDrive] = -127;
      motor[LeftFrontDrive] = -127;
      motor[BackRightDrive] = -127;
      motor[RightFrontDrive] = -127;
			setServo(LeftClaw,120);
	    setServo(RightClaw,-120);
      }
	 motor[BackLeftDrive] = 0;
   motor[LeftFrontDrive] = 0;
   motor[BackRightDrive] = 0;
   motor[RightFrontDrive] = 0;
   setServo(RightClaw, -10);
	 setServo(LeftClaw, -10);

   }

string lft = "lft", rig = "rig", u = "up", dow = "down", rite = "rit", lf = "lef", lifty = "lif";
void auto(){
	if(x == 2 && y == 2 && z == 2){
		reset(lft);
		move(200);
	}

	if(x == 2 && y == 1 && z == 2){
		reset(rite);
		movegrab(-75);
		reset(rite);
		move(-20);
		reset(rite);
		turn(rig, 87);
		reseth(lifty);
		lift(u, 6);
		reset(rite);
		move(-17);
		grab();
		reset(rite);
		moveback(30);
		}

	if(x == 1 && y == 1 && z == 2){
		reset(rite);
		movegrab(-75);
		reset(rite);
		move(-20);
		reset(rite);
		turn(rig, 87);
		reseth(lifty);
		lift(u, 6);
		reset(rite);
		move(-17);
		grab();
		reset(rite);
		moveback(30);
	}

	if(x == 1 && y == 2 && z == 2){
		reset(rite);
		movegrab(-75);
		reset(rite);
		move(-20);
		reset(rite);
		turn(lft, -118);
		reseth(lifty);
		lift(u, 6.2);
		waitInMilliseconds(30);
		reset(rite);
		move(-21);
		lift(dow, 1);
		waitInMilliseconds(30);
		grab();
		reset(rite);
		moveback(30);
		}

	if(x == 1 && y == 1 && z == 1){
		move(-16);
		waitInMilliseconds(20);
		moveback(6);}
	if(x == 2 && y == 1 && z == 1){
		move(-16);
		waitInMilliseconds(20);
		moveback(6);}
	if(x == 1 && y == 2 && z == 1){
		move(-16);
		waitInMilliseconds(20);
		moveback(6);}
	if(x == 2 && y == 2 && z == 1){
		move(-16);
		waitInMilliseconds(20);
		moveback(6);}
		}
task autonomous()
{
	waitInMilliseconds(7000);
	auto();
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task drive(){
	while(true){
	//Right side of the robot is controlled by the right joystick, Y-axis
	motor[BackRightDrive] = vexRT[Ch2];
	motor[RightFrontDrive] = vexRT[Ch2];
	motor[LeftFrontDrive] = vexRT[Ch3];///////////////////////////////////
	motor[BackLeftDrive]  = vexRT[Ch3]; } //
	//Left side of the robot is controlled by the left joystick, Y-axis
}
task bat(){
string mainbattery;
	while(true){
		clearLCDLine(0);
		clearLCDLine(1);

		displayLCDString(0, 0, "Primary: ");
		sprintf(mainbattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V');
		displayNextLCDString(mainbattery);

		wait1Msec(100);}
}
void liftbutton(int height){
	motor[LeftBottomLift] = -127;
	motor[RightBottomLift] = -127;
	motor[TopLeftLift] = -127;
	motor[TopRightLift] = -127;
	untilRotations(height, dgtl7);
	motor[LeftBottomLift] = 0;
	motor[RightBottomLift] = 0;
	motor[TopLeftLift] = 0;
	motor[TopRightLift] = 0;}

task usercontrol(){
	while (true){
		startTask(drive);
		startTask(bat);

		if(vexRT[Btn5D] == 1){
			motor[LeftBottomLift] = 127;
			motor[RightBottomLift] = 127;
			motor[TopLeftLift] = 127;
			motor[TopRightLift] = 127;}

		else if(vexRT[Btn5U] == 1){////////////////////////////THIS CONTROLLS THE LIFT//////////////////////
			motor[LeftBottomLift] = -127;
			motor[RightBottomLift] = -127;
			motor[TopLeftLift] = -127;
			motor[TopRightLift] = -127;}

		else{
			motor[LeftBottomLift] = 0;
			motor[RightBottomLift] = 0;
			motor[TopLeftLift] = 0;
			motor[TopRightLift] = 0;}


		if(vexRT[Btn8U] == 1){
			liftbutton(17.8);
		}

		if(vexRT[Btn8L] == 1){
			liftbutton(17.5);
		}

		if(vexRT[Btn8D] == 1){
			liftbutton(11);
		}

		if(vexRT[Btn6U] == 1){
			setServo(LeftClaw,120);
			setServo(RightClaw,-120);}

		else if(vexRT[Btn6D] == 1){////////////////////////////claw//////////////////////
			setServo(LeftClaw, -127);
			setServo(RightClaw,127);}

		else{
			setServo(RightClaw, -10);
			setServo(LeftClaw, -10);}
	}
}
