#pragma config(Sensor, in1,    zAccel,         sensorAccelerometer)
#pragma config(Sensor, in2,    yAccel,         sensorAccelerometer)
#pragma config(Sensor, in3,    xAccel,         sensorAccelerometer)
#pragma config(Sensor, dgtl3,  lef,            sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  rit,            sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  lif,            sensorQuadEncoder)
#pragma config(Motor,  port1,           BackRightDrive, tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           BackLeftDrive, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           LeftBottomLift, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           RightClaw,     tmotorServoStandard, openLoop)
#pragma config(Motor,  port5,           TopRightLift,  tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           TopLeftLift,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           LeftClaw,      tmotorServoStandard, openLoop)
#pragma config(Motor,  port8,           LeftFrontDrive, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           RightFrontDrive, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          RightBottomLift, tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////
int a;
int b;
int userinput(){
	while(true){
		if(nLCDButtons == 1){
			return 1;}
		if(nLCDButtons == 4){
			return 2;}
	}
}
void LCD(){
	bLCDBacklight = true;
	displayLCDCenteredString(0, "Team?");
	displayLCDString(0, 0, "Red         Blue");
	a = userinput();
	displayLCDCenteredString(0, "Side?");
	displayLCDString(0, 0, "Left       Right");
	waitInMilliseconds(500);
	b = userinput();
	if(a == 1 & b == 1){
		displayLCDCenteredString(0, "Red, Left");}
	if(a == 1 & b == 2){
		displayLCDCenteredString(0, "Red, Right");}
	if(a == 2 & b == 1){
		displayLCDCenteredString(0, "Blue, Left");}
	if(a == 2 & b == 2){
		displayLCDCenteredString(0, "Blue, Right");}
}
void pre_auton(){
	LCD();
	bStopTasksBetweenModes = false;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////
void reset(string encode){
	if(encode == "rit"){
		SensorValue(rit) = 0;}
}
void reseth(string enc){
	if(enc == "lif"){
		SensorValue(lif) = 0;}
}
void move(int dis){
	while(SensorValue[rit] > dis){
        motor[BackLeftDrive] = 127;
        motor[LeftFrontDrive] = 127;
        motor[BackRightDrive] = 127;
        motor[RightFrontDrive] = 127;
      }
    motor[BackLeftDrive] = 0;
    motor[LeftFrontDrive] = 0;
    motor[BackRightDrive] = 0;
    motor[RightFrontDrive] = 0;}

void moveback(int dis){
	while(SensorValue[rit] < dis){
			motor[BackLeftDrive] = -127;
      motor[LeftFrontDrive] = -127;
      motor[BackRightDrive] = -127;
      motor[RightFrontDrive] = -127;}
	 motor[BackLeftDrive] = 0;
   motor[LeftFrontDrive] = 0;
   motor[BackRightDrive] = 0;
   motor[RightFrontDrive] = 0;}

void movegrab(int distance){
    while(SensorValue[rit] > distance){
        motor[BackLeftDrive] = 127;
        motor[LeftFrontDrive] = 127;
        motor[BackRightDrive] = 127;
        motor[RightFrontDrive] = 127;
        setServo(LeftClaw,120);
				setServo(RightClaw,-120);
    }
    motor[BackLeftDrive] = 0;
    motor[LeftFrontDrive] = 0;
    motor[BackRightDrive] = 0;
    motor[RightFrontDrive] = 0;
    setServo(RightClaw, -10);
		setServo(LeftClaw, -10);
}



void turn(string side, int degre){
	if(side == "lft"){
		while(SensorValue[rit] > degre){
			motor[BackRightDrive] = 127;
			motor[RightFrontDrive] = 127;
			motor[LeftFrontDrive] = -127;
			motor[BackLeftDrive]  = -127;}
		motor[BackRightDrive] = 0;
		motor[RightFrontDrive] = 0;
		motor[LeftFrontDrive] = 0;
		motor[BackLeftDrive]  = 0;
	}
	if(side == "rig"){
		while(SensorValue[rit] < degre){
			motor[BackRightDrive] = -127;
			motor[RightFrontDrive] = -127;
			motor[LeftFrontDrive] = 127;
			motor[BackLeftDrive]  = 127;
			}
		motor[BackRightDrive] = 0;
		motor[RightFrontDrive] = 0;
		motor[LeftFrontDrive] = 0;
		motor[BackLeftDrive]  = 0;}
	}

void grab(){
	setServo(LeftClaw,120);
	setServo(RightClaw,-120);
waitInMilliseconds(500);
	setServo(RightClaw, -10);
	setServo(LeftClaw, -10);}

void lift(string vertic, int place){
	if(vertic == "down"){
		motor[LeftBottomLift] = 127;
		motor[RightBottomLift] = 127;
		motor[TopLeftLift] = 127;
		motor[TopRightLift] = 127;
		untilRotations(place, lif);
		motor[LeftBottomLift] = 0;
		motor[RightBottomLift] = 0;
		motor[TopLeftLift] = 0;
		motor[TopRightLift] = 0;}
	if(vertic == "up"){
		motor[LeftBottomLift] = -127;
		motor[RightBottomLift] = -127;
		motor[TopLeftLift] = -127;
		motor[TopRightLift] = -127;
		untilRotations(place, lif);
		motor[LeftBottomLift] = 0;
		motor[RightBottomLift] = 0;
		motor[TopLeftLift] = 0;
		motor[TopRightLift] = 0;}
}
void movebackgrab(int dist){
		while(SensorValue[rit] < dist){
			motor[BackLeftDrive] = -127;
      motor[LeftFrontDrive] = -127;
      motor[BackRightDrive] = -127;
      motor[RightFrontDrive] = -127;
      setServo(LeftClaw,120);
			setServo(RightClaw,-120);
      }
	 motor[BackLeftDrive] = 0;
   motor[LeftFrontDrive] = 0;
   motor[BackRightDrive] = 0;
   motor[RightFrontDrive] = 0;
   setServo(RightClaw, -10);
	 setServo(LeftClaw, -10);
   }

string lft = "lft", rig = "rig", u = "up", dow = "down", rite = "rit", lf = "lef", lifty = "lif";
void auto(){
	if(a == 1 && b == 1){
		reset(rite);
		movegrab(-75);
		reset(rite);
		move(-20);
		reset(rite);
		turn(rig, 92);
		reseth(lifty);
		lift(u, 2.5);
		reset(rite);
		move(-17);
		grab();
		reset(rite);
		moveback(30);
		reset(rite);
		turn(lft, -117);
		lift(dow, 2.5);
		reset(rite);
		movegrab(-85);
		reset(rite);
		turn(lft, -70);
		reset(rite);
		move(-125);
		reset(rite);
		movegrab(-75);
		reset(rite);
		turn(rig, 8);
		reset(rite);
		move(-117);
		reset(rite);
		turn(lft, -73);
		lift(u, 4);
		reset(rite);
		move(-65);
		reset(rite);
		lift(dow, 0.2);
		movebackgrab(20);
		lift(dow, 4);
		reset(rite);
		movegrab(-44);
		reset(rite);
		moveback(10);
		lift(u, 11);
		reset(rite);
		move(-17);
		lift(dow, 7);
		grab();

	}
}

task autonomous()
{

	auto();

}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task drive(){
	while(true){
	//Right side of the robot is controlled by the right joystick, Y-axis
	motor[BackRightDrive] = vexRT[Ch2];
	motor[RightFrontDrive] = vexRT[Ch2];
	motor[LeftFrontDrive] = vexRT[Ch3];///////////////////////////////////
	motor[BackLeftDrive]  = vexRT[Ch3]; } //
	//Left side of the robot is controlled by the left joystick, Y-axis
}
void liftbutton(int height){
	motor[LeftBottomLift] = -127;
	motor[RightBottomLift] = -127;
	motor[TopLeftLift] = -127;
	motor[TopRightLift] = -127;
	untilRotations(height, dgtl7);
	motor[LeftBottomLift] = 0;
	motor[RightBottomLift] = 0;
	motor[TopLeftLift] = 0;
	motor[TopRightLift] = 0;}

task usercontrol(){
	while (true){
		startTask(drive);

		if(vexRT[Btn5D] == 1){
			motor[LeftBottomLift] = 127;
			motor[RightBottomLift] = 127;
			motor[TopLeftLift] = 127;
			motor[TopRightLift] = 127;}

		else if(vexRT[Btn5U] == 1){////////////////////////////THIS CONTROLLS THE LIFT//////////////////////
			motor[LeftBottomLift] = -127;
			motor[RightBottomLift] = -127;
			motor[TopLeftLift] = -127;
			motor[TopRightLift] = -127;}

		else{
			motor[LeftBottomLift] = 0;
			motor[RightBottomLift] = 0;
			motor[TopLeftLift] = 0;
			motor[TopRightLift] = 0;}


		if(vexRT[Btn8U] == 1){
			liftbutton(17.8);
		}

		if(vexRT[Btn8L] == 1){
			liftbutton(17.5);
		}

		if(vexRT[Btn8D] == 1){
			liftbutton(11);
		}

		if(vexRT[Btn6U] == 1){
			setServo(LeftClaw,120);
			setServo(RightClaw,-120);}

		else if(vexRT[Btn6D] == 1){////////////////////////////claw//////////////////////
			setServo(LeftClaw, -127);
			setServo(RightClaw,127);}

		else{
			setServo(RightClaw, -10);
			setServo(LeftClaw, -10);}
	}
}
